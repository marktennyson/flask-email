{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flask-mailing","text":"<p>Flask-Mailing is a highly efficient and user-friendly package that enables <code>Asynchronous</code> email messaging in Flask applications. Asynchronous email messaging is becoming increasingly popular because it allows applications to continue running while emails are being sent in the background. This makes it an ideal solution for time-sensitive applications that require a fast and responsive user experience.</p> <p>With Flask-Mailing, developers can easily integrate asynchronous email messaging capabilities into their Flask applications without the need for complex configurations or additional dependencies. The package offers a variety of features, including support for multiple email providers, email templates, and error handling. It also supports common email protocols, such as <code>SMTP</code>, <code>SSL</code>, and <code>TLS</code>.</p> <p>Moreover, Flask-Mailing offers a simple and intuitive API that allows developers to easily send emails in the background. It also provides advanced features, such as email tracking and reporting, which enable developers to monitor email performance and user engagement.</p> <p>Whether you're building a small-scale application or a large-scale enterprise system, Flask-Mailing provides a reliable and scalable solution for Asynchronous email messaging in Flask applications.</p> <p>Flask-Mail has been discontinued. However, you can still use email services with your Flask projects by using either Flask-Mailing for asynchronous implementation or Flask-Mailman for synchronous implementation.</p> <ul> <li> <p>Flask-Mailing supports asynchronous email sending using the built-in <code>asyncio</code> library in Python 3.5+. It easily integrates with Flask applications using the provided <code>Mail</code> extension, offers simple and intuitive configuration options for email providers, supports HTML and plain-text message formats, and provides options for customizing email headers and message priority levels. It also includes customizable email templates, supports file attachments, and allows for bulk email sending, email tracking, encryption and authentication, error handling, and logging functionality.</p> </li> <li> <p>Flask-Mailman, on the other hand, provides a simple API for sending email messages synchronously, supports HTML and plain-text message formats, allows for customizing email headers and message priority levels, and provides options for email tracking and error handling. It also includes customizable email templates and supports file attachments.</p> </li> </ul> <p>Choose the package that best fits your project's requirements and start using email services with your Flask application!</p> <p>Flask_Mail is dead now. To use the mail service with your project you can use eaither Flask-Mailing for Asynchronous or Flask-Mailman for Synchronous implementation.</p> <p> </p>"},{"location":"#a-basic-demo-for-better-understanding","title":"A Basic Demo for better understanding","text":"<pre><code>from flask import Flask, jsonify\nfrom flask_mailing import Mail, Message\n\nmail = Mail()\n\ndef create_app():\n    app = Flask(__name__)\n\n\n    app.config['MAIL_USERNAME'] = \"your-email@your-domain.com\"\n    app.config['MAIL_PASSWORD'] = \"world_top_secret_password\"\n    app.config['MAIL_PORT'] = 587\n    app.config['MAIL_SERVER'] = \"your-email-server.com\"\n    app.config['MAIL_USE_TLS'] = True\n    app.config['MAIL_USE_SSL'] = False\n    app.config['MAIL_DEFAULT_SENDER'] = \"your-email@your-domain.com\"\n    mail.init_app(app)\n\n    return app\n\n#send a simple email using flask_mailing module.\n\napp = create_app()\n\n@app.get(\"/email\")\nasync def simple_send():\n\n    message = Message(\n        subject=\"Flask-Mailing module\",\n        recipients=[\"aniketsarkar@yahoo.com\"],\n        body=\"This is the basic email body\",\n        )\n\n\n    await mail.send_message(message)\n    return jsonify(status_code=200, content={\"message\": \"email has been sent\"})\n</code></pre>"},{"location":"#using-jinja2-html-templates","title":"Using Jinja2 HTML Templates","text":"<p>In order to use Jinja template langauge, your must specify email folder within your applications working directory.</p> <p>In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Flask mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \"body\" and that it is a python dict.</p> <p>check out jinja2 for more details  jinja2</p>"},{"location":"#guide-for-email-utils","title":"Guide for Email Utils","text":"<p>The utility allows you to check temporary email addresses, you can block any email or domain.  You can connect Redis to save and check email addresses. If you do not provide a Redis configuration,  then the utility will save it in the list or set by default.</p>"},{"location":"#writing-unittests-using-flask-mailing","title":"Writing unittests using Flask-Mailing","text":"<p>Flask mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications.</p>"},{"location":"#support-for-reply-to-header-is-added","title":"Support for Reply-To header is added","text":"<p>Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-023","title":"Version 0.2.3","text":"<p>Release Date: September 19, 2023  </p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Introduced compatibility with Pydantic V2, ensuring seamless integration with the latest versions.  </li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Resolved several bugs related to configuration handling and email validation.  </li> <li>Improved overall stability and robustness of the library.  </li> </ul>"},{"location":"changelog/#version-022","title":"Version 0.2.2","text":"<p>Release Date: January 14, 2023  </p>"},{"location":"changelog/#updated","title":"Updated","text":"<ul> <li>Enhanced the <code>setup.py</code> to streamline installation and dependency management.  </li> <li>Revised the README file for better clarity and up-to-date documentation.  </li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Addressed versioning inconsistencies to avoid compatibility issues.  </li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Full compatibility with Python 3.11.  </li> </ul>"},{"location":"changelog/#version-021","title":"Version 0.2.1","text":"<p>Release Date: January 11, 2023  </p>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Resolved <code>aioredis</code> compatibility issues for Python 3.11.  </li> <li>Fixed a critical bug in the <code>httpx</code> library dependency.  </li> </ul>"},{"location":"changelog/#version-020","title":"Version 0.2.0","text":"<p>Release Date: Febuary 16, 2022  </p>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Introduced <code>send_mail</code> and <code>send_mass_mail</code> methods, similar to Django or Flask-Mailman.  </li> <li>Added extensive docstrings for better API understanding.  </li> <li>Expanded the test suite with additional test cases to ensure reliability.  </li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Corrected a significant issue in the <code>MAIL_START_TLS</code> and <code>MAIL_START_SSL</code> configurations in the <code>ConnectionConfig</code> module.  </li> </ul>"},{"location":"changelog/#version-011","title":"Version 0.1.1","text":"<p>Release Date: January 19, 2022 </p>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Enabled compatibility with <code>aioredis &gt; 2.0.0</code>.  </li> <li>Introduced asynchronous support for the <code>utils.email_check.EmailChecker</code> class.  </li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Resolved test case issues with the fake Redis client.  </li> <li>Corrected typos in the <code>utils.email_check</code> file.  </li> </ul>"},{"location":"changelog/#updated_1","title":"Updated","text":"<ul> <li>Updated the <code>utils.email_check.EmailChecker</code> class for the latest version of <code>aioredis</code>.  </li> <li>Refined dependency management to ensure compatibility with new versions.  </li> </ul>"},{"location":"changelog/#version-010","title":"Version 0.1.0","text":"<p>Release Date: January 12, 2022  </p>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Included support for template parameters via the <code>template_params</code> variable in the <code>schemas.Message</code> class.  </li> <li>Added module-level docstrings to improve documentation clarity.  </li> <li>Documented a future roadmap for feature enhancements.  </li> <li>Expanded compatibility to Python 3.10.  </li> <li>Enabled users to create custom headers for email attachments.  </li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Resolved issue #20, allowing seamless usage of template parameters.  </li> <li>Addressed typos and configuration errors in the <code>setup.py</code> file.  </li> <li>Fixed broken test cases and improved test coverage.  </li> <li>Corrected variable naming issues in the <code>config.ConnectionConfig</code> class.  </li> <li>Fixed <code>Literal</code> import issues for Python 3.6 and 3.7.  </li> </ul>"},{"location":"changelog/#updated_2","title":"Updated","text":"<ul> <li>Revised the <code>MANIFEST.in</code> file for better packaging.  </li> <li>Updated dependencies to the latest stable versions.  </li> </ul>"},{"location":"changelog/#older-versions","title":"Older Versions","text":""},{"location":"changelog/#version-007","title":"Version 0.0.7","text":"<ul> <li>Fixed the \"long description not found\" issue on the PyPI website.  </li> </ul>"},{"location":"changelog/#version-006","title":"Version 0.0.6","text":"<ul> <li>Enabled access to the <code>Mail</code> object via <code>app.extensions['mailing']</code>.  </li> </ul>"},{"location":"changelog/#version-005","title":"Version 0.0.5","text":"<ul> <li>Added a new configuration variable, <code>MAIL_DEFAULT_SENDER</code>, with functionality similar to <code>MAIL_FROM</code>.  </li> <li>Fixed the absence of the <code>httpx</code> module in <code>setup.py</code>.  </li> <li>Renamed <code>MAIL_SSL</code> and <code>MAIL_TLS</code> to <code>MAIL_USE_SSL</code> and <code>MAIL_USE_TLS</code>, respectively.  </li> <li>Introduced the <code>add_recipient</code> and <code>attach</code> methods in the <code>schemas.Message</code> class.  </li> <li>Updated documentation and resolved broken test cases.  </li> </ul>"},{"location":"changelog/#version-004","title":"Version 0.0.4","text":"<ul> <li>Added setup details to <code>pyproject.toml</code> to resolve dependency errors.  </li> </ul>"},{"location":"changelog/#version-002","title":"Version 0.0.2","text":"<ul> <li>Updated dependencies.  </li> </ul>"},{"location":"contribute/","title":"Contributing to flask-mailing","text":"<p>We welcome contributions to flask-mailing</p>"},{"location":"contribute/#issues","title":"Issues","text":"<p>Feel free to submit issues and enhancement requests.</p> <p>Flask-Mailing Issues</p>"},{"location":"contribute/#contributing","title":"Contributing","text":"<p>Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow.</p> <ol> <li>Fork the repo on GitHub</li> <li>Clone the project to your own machine</li> <li>Commit changes to your own branch</li> <li>Push your work </li> <li>Submit a Pull request so that we can review your changes</li> </ol> <p>NOTE: Be sure to merge the latest from <code>upstream</code> before making a pull request!</p>"},{"location":"example/","title":"Example","text":""},{"location":"example/#sending-emails-using-flask-mailing","title":"Sending emails using Flask-Mailing","text":""},{"location":"example/#list-of-examples","title":"List of Examples","text":""},{"location":"example/#basic-configuration","title":"Basic configuration","text":"<pre><code>from flask import Flask, jsonify\nfrom flask_mailing import Mail, Message\n\nmail = Mail()\n\ndef create_app():\n    app = Flask(__name__)\n\n\n    app.config['MAIL_USERNAME'] = \"your-email@your-domain.com\"\n    app.config['MAIL_PASSWORD'] = \"world_top_secret_password\"\n    app.config['MAIL_PORT'] = 587\n    app.config['MAIL_SERVER'] = \"your-email-server.com\"\n    app.config['MAIL_USE_TLS'] = True\n    app.config['MAIL_USE_SSL'] = False\n    mail.init_app(app)\n\n    return app\n\n#send a simple email using flask_mailing module.\n\napp = create_app()\n\n@app.get(\"/email\")\nasync def simple_send():\n\n    message = Message(\n        subject=\"Flask-Mailing module\",\n        recipients=[\"aniketsarkar@yahoo.com\"],\n        body=\"This is the basic email body\",\n        )\n\n\n    await mail.send_message(message)\n    return jsonify(status_code=200, content={\"message\": \"email has been sent\"})\n</code></pre>"},{"location":"example/#add-recipient-using-add_recipient-method","title":"Add recipient using <code>add_recipient</code> method","text":"<pre><code>message.add_recipient(\"recipient@emldomain.com\")\n</code></pre>"},{"location":"example/#send-a-simple-html-message","title":"Send a simple html message","text":"<pre><code>html = \"\"\"\n&lt;p&gt;Hi this test mail, thanks for using Flask-Mailing&lt;/p&gt; \n\"\"\"\n\n@app.get(\"/html-email\")\nasync def html_email():\n\n    message = Message(\n        subject=\"Flask-Mailing module test html mail\",\n        recipients=[\"aniketsarkar@yahoo.com\"],\n        body=html,\n        subtype=\"html\"\n        )\n\n\n    await mail.send_message(message)\n    return jsonify(status_code=200, content={\"message\": \"email has been sent\"})\n</code></pre>"},{"location":"example/#sending-files","title":"Sending files","text":"<pre><code>@app.get(\"/mail-file\")\nasync def mail_file():\n    message = Message(\n        subject = \"attachments based email\",\n        recipients = [\"aniketsarkar@yahoo.com\"],\n        body = \"email with attachments, email body.\",\n        attachments = ['attachments/attachment.txt']\n    )\n    await mail.send_message(message)\n    return jsonify(message=\"email sent\")\n</code></pre>"},{"location":"example/#sending-files-using-attach-method","title":"Sending files using <code>attach</code> method","text":"<pre><code>with app.open_resource(\"attachments/example.txt\") as fp:\n    message.attach(\"example.txt\", fp.read())\n</code></pre>"},{"location":"example/#using-jinja2-html-templates","title":"Using Jinja2 HTML Templates","text":"<p>You can enable Jinja2 HTML Template emails by setting the <code>TEMPLATE_FOLDER</code> configuration option, and supplying a value (which is just the name of the template file within the <code>TEMPLATE_FOLDER</code> dir) for the <code>template_name</code> parameter in <code>Mail.send_message()</code>. You then can pass a Dict as the <code>template_body</code> property of your <code>Message</code> object. If you haven't provided the <code>TEMPLATE_FOLDER</code> configuration option, then the module will take the app's jinja2 environment for templating and you can use templates from app's default template folder:</p> <p><pre><code>from pathlib import Path\n\napp.config[\"TEMPLATE_FOLDER\"] = Path(__file__).parent / 'email-templates'\n\"\"\"\nDon't use this configuration if you want to use the default jinja2 environment.\n\"\"\"\n@app.get(\"/mail-html\")\nasync def mail_html():\n\n    message = Message(\n        subject = \"html template based email\",\n        recipients = [\"aniketsarkar@yahoo.com\"],\n        template_body = {\n                        \"first_name\": \"Hare\",\n                        \"last_name\": \"Krishna\"\n                        }\n        # attachments = ['attachments/attachment.txt']\n    )\n    #or\n    message = Message(\n        subject = \"html template based email\",\n        recipients = [\"aniketsarkar@yahoo.com\"],\n        template_params = {\n                        \"first_name\": \"Hare\",\n                        \"last_name\": \"Krishna\"\n                        }\n        # attachments = ['attachments/attachment.txt']\n    )\n\n    await mail.send_message(message, template_name=\"test.html\")\n    return jsonify(message=\"email sent\")\n</code></pre> For example, assume we pass a <code>template_body</code> of: <pre><code>{\n  \"first_name\": \"Hare\",\n  \"last_name\": \"Krishna\"\n}\n</code></pre> We can reference the variables in our Jinja templates as per normal: <pre><code>...\n&lt;span&gt;Hello, {{ first_name }}!&lt;/span&gt;\n...\n</code></pre></p>"},{"location":"example/#legacy-behaviour","title":"Legacy Behaviour","text":"<p>The original behaviour was to wrap the Dict you provide in a variable named <code>body</code> when it was provided to  Jinja behind the scenes. In these versions, you can then access your dict in your template like so:</p> <pre><code>...\n&lt;span&gt;Hello,  body.first_name !&lt;/span&gt;\n...\n</code></pre> <p>As you can see our keys in our dict are no longer the top level, they are part of the <code>body</code> variable. Nesting works  as per normal below this level also. </p>"},{"location":"example/#customizing-attachments-by-headers-and-mime-type","title":"Customizing attachments by headers and MIME type","text":"<p>Used for example for referencing Content-ID images in html of email</p> <pre><code>message = Message(\n    subject='Flask-Mailing module',\n    recipients=recipients,\n    html=\"&lt;img src='cid:logo_image'&gt;\",\n    subtype='html',\n    attachments=[\n            {\n                \"file\": \"/path/to/file.png\"),\n                \"headers\": {\"Content-ID\": \"&lt;logo_image&gt;\"},\n                \"mime_type\": \"image\",\n                \"mime_subtype\": \"png\",\n            }\n        ],\n)\n\nawait mail.send_message(message)\n</code></pre>"},{"location":"example/#guide-for-email-utils","title":"Guide for email utils","text":"<p>The utility allows you to check temporary email addresses, you can block any email or domain.  You can connect Redis to save and check email addresses. If you do not provide a Redis configuration,  then the utility will save it in the list or set by default.</p>"},{"location":"example/#check-dispasoble-email-address","title":"Check dispasoble email address","text":"<pre><code>async def default_checker():\n    checker = DefaultChecker()  # you can pass source argument for your own email domains\n    await checker.fetch_temp_email_domains() # require to fetch temporary email domains\n    return checker\n\n@app.get('/email/dispasoble')\nasync def simple_send():\n    domain = \"gmail.com, \n    checker = await default_checker()\n    if await checker.is_dispasoble(domain):\n        return jsonify(status_code=400, content={'message': 'this is dispasoble domain'})\n\n    return jsonify(status_code=200, content={'message': 'email has been sent'})\n</code></pre>"},{"location":"example/#add-dispasoble-email-address","title":"Add dispasoble email address","text":"<pre><code>@app.get('/email/dispasoble')\nasync def add_disp_domain():\n    domains: list = [\"gmail.com\"]\n    checker: DefaultChecker = await default_checker()\n\n    res = await checker.add_temp_domain(domains)\n\n    return jsonify(status_code=200, content={'result': res})\n</code></pre>"},{"location":"example/#add-domain-to-blocked-list","title":"Add domain to blocked list","text":"<pre><code>@app.get('/email/blocked/domains')\nasync def block_domain():\n    domain: str = \"gmail.com\"\n    checker: DefaultChecker = await default_checker()\n\n    await checker.blacklist_add_domain(domain)\n\n    return jsonify(status_code=200, content={'message': f'{domain} added to blacklist'})\n</code></pre>"},{"location":"example/#check-domain-blocked-or-not","title":"Check domain blocked or not","text":"<pre><code>@app.get('/email/blocked/check-domains')\nasync def get_blocked_domain():\n    domain: str ='gmail.com'\n    checker: DefaultChecker = await default_checker()\n    res = await checker.is_blocked_domain(domain)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#add-email-address-to-blocked-list","title":"Add email address to blocked list","text":"<pre><code>@app.get('/email/blocked/address')\nasync def block_address():\n    email: str ='hacker@gmail.com'\n    checker: DefaultChecker = await default_checker()\n    await checker.blacklist_add_email(email)\n\n    return jsonify(status_code=200, content={\"result\": True})\n</code></pre>"},{"location":"example/#check-email-blocked-or-not","title":"Check email blocked or not","text":"<pre><code>@app.get('/email/blocked/address')\nasync def get_block_address():\n    email: str ='hacker@gmail.com'\n    checker: DefaultChecker = await default_checker()\n    res = await checker.is_blocked_address(email)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#check-mx-record","title":"Check MX record","text":"<pre><code>@app.get(\"/email/check-mx\")\nasync def check_mx_record():\n    checker = await default_checker()\n    domain = \"gmail.com\"\n    res = await checker.check_mx_record(domain, False)\n\n    return jsonify(status_code=200, content={'result': res})\n</code></pre>"},{"location":"example/#remove-email-address-from-blocked-list","title":"Remove email address from blocked list","text":"<pre><code>@app.get('/email/blocked/address')\nasync def del_blocked_address():\n    checker = await default_checker()\n    email = \"hacker@gmail.com\"\n    res = await checker.blacklist_rm_email(email)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#remove-domain-from-blocked-list","title":"Remove domain from blocked list","text":"<pre><code>@app.get('/email/blocked/domains')\nasync def del_blocked_domain():\n    checker = await default_checker()\n    domain = \"gmail.com\"\n    res = await checker.blacklist_rm_domain(domain)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#remove-domain-from-temporary-list","title":"Remove domain from temporary list","text":"<pre><code>@app.get('/email/dispasoblee')\nasync def del_disp_domain():\n    checker = await default_checker()\n    domains = [\"gmail.com\"]\n    res = await checker.blacklist_rm_temp(domains)\n\n    return jsonify(status_code=200, content={'result': res})\n</code></pre>"},{"location":"example/#whoisxmlapi","title":"WhoIsXmlApi","text":"<pre><code>from flask_mailing.utils import WhoIsXmlApi\n\nwho_is = WhoIsXmlApi(token=\"Your access token\", email=\"your@mailaddress.com\")\n\nprint(who_is.smtp_check_())    #check smtp server\nprint(who_is.is_dispasoble()) # check email is disposable or not\nprint(who_is.check_mx_record()) # check domain mx records \nprint(who_is.free_check) # check email domain is free or not\n</code></pre>"},{"location":"getting-started/","title":"\ud83d\udd79 Getting Started","text":""},{"location":"getting-started/#guide","title":"\ud83d\udd79 Guide","text":"<p>After installing the module and setting up your <code>Flask</code> app:</p> <p>Main classes and packages are <code>Mail</code> <code>Message</code> <code>utils.DefaultChecker</code> <code>utils.WhoIsXmlApi</code></p>"},{"location":"getting-started/#available-config-options","title":"Available config options","text":"<p>class has following attributes</p> <ul> <li>MAIL_USERNAME  : Username for email, some email hosts separates username from the default sender(AWS).<ul> <li>If you service does not provide username use sender address for connection.</li> </ul> </li> <li>MAIL_PASSWORD : Password for authentication</li> <li>MAIL_SERVER  : SMTP Mail server.</li> <li>MAIL_USE_TLS : For TLS connection</li> <li>MAIL_USE_SSL : For SSL connection</li> <li>MAIL_DEBUG : Debug mode for while sending mails, defaults 0.</li> <li>MAIL_FROM : Sender address</li> <li>MAIL_DEFAULT_SENDER : Sender address</li> <li>MAIL_FROM_NAME : Title for Mail</li> <li>TEMPLATE_FOLDER: If you are using jinja2, specify template folder name</li> <li>SUPPRESS_SEND:  To mock sending out mail, defaults 0.</li> <li>USE_CREDENTIALS: Defaults to <code>True</code>. However it enables users to choose whether or not to login to their SMTP server.</li> <li>VALIDATE_CERTS: Defaults to <code>True</code>. It enables to choose whether to verify the mail server's certificate</li> </ul>"},{"location":"getting-started/#mail-class","title":"<code>Mail</code> class","text":"<p>class has following attributes and methods</p> <ul> <li> <p><code>send_message</code> : The methods has two atributes, message: Message, template_name=None</p> <ul> <li>message : where you define message sturcture for email</li> <li>template_name : if you are using jinja2 consider template_name as well for passing HTML.</li> </ul> </li> <li> <p><code>send_mail</code> : sending emails with message string and recipients very similar to Django.</p> <ul> <li>subject : A String containing the subject of the message.</li> <li>message : A string containing the message body.</li> <li>recipients : A list of strings, each an email address. Each member of recipients will see the other recipients in the \u201cTo:\u201d field of the email message.</li> <li>msgkwargs : the kwargs based parameters for <code>Message</code> class.</li> </ul> </li> <li> <p><code>send_mass_mail</code> : To handle mass mailing.</p> <ul> <li>datatuple : is a tuple in which each element is in this format:     <pre><code>(subject, message, recipients)\n</code></pre></li> </ul> </li> </ul>"},{"location":"getting-started/#message-class","title":"<code>Message</code> class","text":"<p>class has following attributes</p> <ul> <li>recipients  : List of recipients.</li> <li>attachments : attachments within mail.</li> <li>subject  : subject content of the mail.</li> <li>body : body of the message.</li> <li>template_body: parameters for the jinja template.</li> <li>template_params: parameters for the jinja template.</li> <li>cc : cc recipients of the mail.</li> <li>bcc : bcc recipients of the mail.</li> <li>reply_to : Reply-To recipients in the mail.</li> <li>charset : charset defaults to utf-8.</li> <li>subtype : subtype of the mail defaults to plain.</li> <li>add_recipient : a method to add additional recipients.</li> <li>attach : a method to add additional attachments.</li> </ul>"},{"location":"getting-started/#utilsdefaultchecker-class","title":"<code>utils.DefaultChecker</code> class","text":"<p>Default class for checking email from collected public resource. The class makes it possible to use redis to save data.</p> <ul> <li>source  : <code>optional</code> source for collected email data.</li> <li>db_provider  : switch to redis</li> </ul>"},{"location":"getting-started/#utilswhoisxmlapi-class","title":"<code>utils.WhoIsXmlApi</code> class","text":"<p>WhoIsXmlApi class provide working with api  WhoIsXmlApi This service gives free 1000 request to checking email address per month.</p> <ul> <li>token  : token you can get from this WhoIsXmlApi link</li> <li>email  : email for checking</li> </ul>"},{"location":"install/","title":"\ud83d\udd28 Installation","text":""},{"location":"install/#using-pip","title":"Using pip","text":"<pre><code>python3 -m venv .venv\n\nsource .venv/bin/activate\n\npip install flask-mailing\n</code></pre>"},{"location":"install/#using-source-code","title":"Using source code","text":"<pre><code>git clone https://github.com/marktennyson/flask-mailing &amp;&amp; cd flask-mailing\npython3 setup.py install\n</code></pre>"}]}